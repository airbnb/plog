plog {
  // The port to listen to
  port = 23456

  // The Kafka topic we will send messages to
  topic = plog

  // Threads
  threads = 4

  udp {
    SO_RCVBUF = 1048576
    SO_SNDBUF = 1048576
    RECV_SIZE = 65536
  }

  defrag {
    // maximum memory in bytes used to track incoming messages
    max_size = 1048576
    // maximum time to wait after the last message is received
    // to call it quits for that message
    expire_time = 10s

    // detect holes in message IDs
    // requires message IDs to be continuously incrementing
    detect_holes {
      // counters will still be reported (at 0) if disabled
      enabled = true

      // how many ports to track before evicting old ones.
      // cheap enough, really
      ports = 1024

      // track a reasonably low amount of IDs per port
      // for fast loss discovery
      ids_per_port = 10

      // every new message renews a port's lease.
      // as ports will be recycled, it is useful to avoid crazy stats.
      expire_time = 10m

      // if a hole between IDs is bigger, it's probably due to a recycled port.
      maximum_hole = 100
    }
  }
}
